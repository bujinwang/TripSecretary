# 离线模式 - 技术设计文档

> **核心目标**: 确保用户在边境、WiFi不稳定环境下仍能正常使用APP
> **注意**: 所有用户都需要注册账号使用，无访客模式

---

## 一、为什么需要离线模式？

### 1.1 真实场景分析

**场景1: 机场/边境口岸网络差**
```
用户在深圳湾口岸准备过关去香港
├── 手机信号：满格
├── 实际网速：<100kb/s (大量人同时用WiFi)
├── API调用：超时
└── 问题：无法生成通关包 ❌
```

**场景2: 国际漫游费贵**
```
用户刚下飞机到达泰国曼谷机场
├── 还没买当地SIM卡
├── 漫游费：¥3/MB
├── 只能用机场免费WiFi
└── WiFi速度：不稳定，时断时续
```

**场景3: 忘记提前下载数据**
```
王阿姨在香港机场
├── 手机没信号
├── WiFi连不上
├── 海关快到了，很着急
├── 但她出发前已经生成了通关包
└── 结果：所有数据已缓存，完全离线也能用 ⭐
```

### 1.2 离线能力分级

| 功能 | 在线必需？ | 离线可用？ | 优先级 |
|------|----------|----------|-------|
| 📸 拍照识别证件 | ❌ | ✅ 本地OCR | P0 |
| ✓ 验证证件有效性 | ❌ | ✅ 本地规则库 | P0 |
| 📋 生成入境表格 | ❌ | ✅ 本地模板 | P0 |
| 💬 海关问答卡 | ❌ | ✅ 预缓存 | P0 |
| 📱 通关包展示 | ❌ | ✅ 完全离线 | P0 |
| 🌐 实时翻译 | ⚠️ | △ 缓存常见短语 | P1 |
| ☁️ 云端备份 | ✅ | ❌ 需在线 | P2 |
| 📥 上传文件 | ✅ | ⚠️ 离线队列 | P2 |

**结论：核心功能100%离线可用 ⭐**

---

## 二、离线架构设计

### 2.1 三层数据架构

```
┌─────────────────────────────────────────┐
│         Layer 1: 本地优先层             │
│  (Local First - 100%离线可用)           │
├─────────────────────────────────────────┤
│  • PaddleOCR (证件识别)                 │
│  • SQLite (证件数据、政策库)            │
│  • 预生成模板 (5国入境表格)             │
│  • 预缓存问答 (100+常见问题)            │
│  • 翻译短语库 (1000+常用短语)           │
└─────────────────────────────────────────┘
              ↓ 有网络时同步
┌─────────────────────────────────────────┐
│         Layer 2: 缓存层                 │
│  (Cache - 加速响应)                     │
├─────────────────────────────────────────┤
│  • MMKV (快速KV存储)                    │
│  • Redis-like缓存 (API响应)             │
│  • 图片缓存 (用户上传的文件)            │
└─────────────────────────────────────────┘
              ↓ 云端备份
┌─────────────────────────────────────────┐
│         Layer 3: 云端同步层             │
│  (Cloud Sync - 可选)                    │
├─────────────────────────────────────────┤
│  • Cloudflare D1 (SQLite分布式)         │
│  • Cloudflare R2 (加密备份)             │
│  • Workers API (在线时同步)             │
└─────────────────────────────────────────┘
```

### 2.2 核心原则

1. **Local First（本地优先）**
   - 所有读操作优先从本地数据库
   - 写操作立即写入本地，后台同步云端

2. **Optimistic UI（乐观更新）**
   - 用户操作立即响应，不等网络
   - 失败后回滚或重试

3. **Background Sync（后台同步）**
   - 有网络时自动同步
   - 失败的操作加入队列，稍后重试

---

## 三、核心功能离线实现

### 3.1 离线OCR识别

**技术方案：**
```javascript
// /lib/offlineOCR.js
import PaddleOCR from 'react-native-paddle-ocr';
import Tesseract from 'tesseract.js';

class OfflineOCREngine {
  constructor() {
    this.paddleOCR = null;
    this.tesseract = null;
    this.initialized = false;
  }

  // 应用启动时初始化（下载模型）
  async initialize() {
    try {
      // 下载PaddleOCR模型（~50MB）
      await PaddleOCR.downloadModels([
        'chinese_mobile_v2.0', // 中文
        'english_mobile_v2.0'  // 英文
      ]);
      
      // 初始化Tesseract（备用）
      this.tesseract = await Tesseract.createWorker('chi_sim+eng');
      
      this.initialized = true;
      console.log('✅ 离线OCR引擎初始化成功');
    } catch (error) {
      console.error('⚠️ 离线OCR初始化失败', error);
    }
  }

  // 离线识别护照
  async recognizePassport(imageUri) {
    if (!this.initialized) {
      throw new Error('OCR引擎未初始化');
    }

    try {
      // 优先使用PaddleOCR（更快更准）
      const result = await PaddleOCR.recognize({
        imagePath: imageUri,
        language: 'chinese+english',
        type: 'passport'
      });

      return {
        success: true,
        data: this.parsePassportData(result.text),
        confidence: result.confidence,
        source: 'paddle-ocr',
        offline: true
      };
    } catch (error) {
      // 降级到Tesseract
      console.log('PaddleOCR失败，降级到Tesseract');
      const result = await this.tesseract.recognize(imageUri);
      
      return {
        success: true,
        data: this.parsePassportData(result.data.text),
        confidence: result.data.confidence,
        source: 'tesseract',
        offline: true
      };
    }
  }

  // 解析护照数据
  parsePassportData(text) {
    // 使用正则提取关键信息
    const patterns = {
      passportNumber: /[PEG]\d{8}/,
      name: /姓名\/Name[:\s]+([A-Z\s]+)/,
      nationality: /国籍\/Nationality[:\s]+([\u4e00-\u9fa5A-Z]+)/,
      dob: /出生日期\/Date of birth[:\s]+(\d{4}[\.\/]\d{2}[\.\/]\d{2})/,
      expiry: /有效期至\/Date of expiry[:\s]+(\d{4}[\.\/]\d{2}[\.\/]\d{2})/
    };

    const extracted = {};
    for (const [key, pattern] of Object.entries(patterns)) {
      const match = text.match(pattern);
      extracted[key] = match ? match[1] : null;
    }

    return extracted;
  }
}

export default new OfflineOCREngine();
```

**关键点：**
- ✅ 首次安装时下载OCR模型到本地
- ✅ 完全离线识别，无需网络
- ✅ 双引擎备份（PaddleOCR + Tesseract）
- ⚠️ 模型文件~50MB，需提示用户

### 3.2 离线政策库

**数据结构：**
```javascript
// /data/offlinePolicies.json
{
  "version": "2025-06-01",
  "countries": {
    "HK": {
      "name": "香港",
      "nameEn": "Hong Kong",
      "requirements": {
        "mainlandChina": {
          "document": "港澳通行证 + 有效签注",
          "visaRequired": false,
          "arrivalCard": false,
          "passportValidity": "有效期内即可",
          "stayDuration": "根据签注类型（G签7天/14天）"
        },
        "hkResident": {
          "document": "香港身份证 或 香港护照",
          "visaRequired": false,
          "arrivalCard": false
        }
      },
      "commonQuestions": [
        {
          "id": "hk_q1",
          "questionCn": "嚟做乜？",
          "questionZh": "来做什么？",
          "questionEn": "Purpose of visit?",
          "answerCn": "旅遊",
          "answerZh": "旅游",
          "answerEn": "Tourism"
        },
        {
          "id": "hk_q2",
          "questionCn": "逗留幾耐？",
          "questionZh": "停留多久？",
          "questionEn": "How long?",
          "answerTemplate": "{duration}日 / {duration}天 / {duration} days"
        }
        // ... 更多问题
      ],
      "tips": [
        "无需填写入境卡",
        "通关速度快（5-15分钟）",
        "可使用e-道自助通关"
      ]
    },
    "TW": {
      "name": "台湾",
      "requirements": {
        "mainlandChina": {
          "document": "大通证 + 入台证",
          "arrivalCard": true,
          "arrivalCardTemplate": "tw_arrival_card.json"
        }
      },
      // ... 详细政策
    }
    // ... 其他国家
  }
}
```

**离线验证逻辑：**
```javascript
// /lib/offlineValidator.js
import policies from '@/data/offlinePolicies.json';

export async function validateOffline(document, destination) {
  const policy = policies.countries[destination];
  
  if (!policy) {
    return {
      valid: false,
      error: '暂不支持该目的地的离线验证'
    };
  }

  // 根据证件类型选择规则
  const rules = document.type === 'hk_permit' 
    ? policy.requirements.mainlandChina
    : policy.requirements.default;

  // 离线验证
  const checks = {
    documentValid: validateExpiry(document.expiryDate),
    passportValidity: checkPassportValidity(
      document.expiryDate, 
      rules.passportValidity
    ),
    visaRequired: rules.visaRequired
  };

  return {
    valid: Object.values(checks).every(c => c === true),
    checks,
    requirements: rules,
    tips: policy.tips
  };
}

function validateExpiry(expiryDate) {
  const expiry = new Date(expiryDate);
  const now = new Date();
  return expiry > now;
}

function checkPassportValidity(expiryDate, requirement) {
  if (requirement === '有效期内即可') return true;
  
  // 解析"≥6个月"等要求
  const months = parseInt(requirement.match(/\d+/)?.[0] || 0);
  const expiry = new Date(expiryDate);
  const minRequired = new Date();
  minRequired.setMonth(minRequired.getMonth() + months);
  
  return expiry >= minRequired;
}
```

### 3.3 离线表格生成

**预生成模板：**
```javascript
// /data/templates/tw_arrival_card.json
{
  "id": "tw_arrival_card",
  "version": "2025",
  "name": "台湾入境登记表",
  "nameTraditional": "臺灣地區入境登記表",
  "fields": [
    {
      "id": "name",
      "labelTw": "姓名",
      "labelCn": "姓名",
      "labelEn": "Name",
      "type": "text",
      "source": "document.name", // 从证件自动填充
      "required": true
    },
    {
      "id": "permitNumber",
      "labelTw": "大陸地區居民往來臺灣通行證號碼",
      "labelCn": "大陆地区居民往来台湾通行证号码",
      "labelEn": "Mainland Travel Permit Number",
      "type": "text",
      "source": "document.number",
      "required": true
    },
    {
      "id": "purpose",
      "labelTw": "來臺目的",
      "labelCn": "来台目的",
      "labelEn": "Purpose of Visit",
      "type": "select",
      "options": [
        {"value": "tourism", "labelTw": "觀光", "labelCn": "观光", "labelEn": "Tourism"},
        {"value": "business", "labelTw": "商務", "labelCn": "商务", "labelEn": "Business"},
        {"value": "visiting", "labelTw": "探親", "labelCn": "探亲", "labelEn": "Visiting Family"}
      ],
      "default": "tourism"
    },
    {
      "id": "duration",
      "labelTw": "停留天數",
      "labelCn": "停留天数",
      "labelEn": "Duration (days)",
      "type": "number",
      "source": "trip.duration",
      "required": true
    },
    {
      "id": "addressInTW",
      "labelTw": "在臺住址",
      "labelCn": "在台住址",
      "labelEn": "Address in Taiwan",
      "type": "text",
      "source": "trip.hotel.address",
      "required": true
    }
    // ... 更多字段
  ]
}
```

**离线生成器：**
```javascript
// /lib/offlineFormGenerator.js
import templates from '@/data/templates';

export async function generateArrivalCardOffline(
  userDocument, 
  tripInfo, 
  destination
) {
  // 加载模板
  const template = templates[`${destination}_arrival_card`];
  
  if (!template) {
    throw new Error(`没有${destination}的离线模板`);
  }

  // 填充数据
  const filledForm = template.fields.map(field => {
    let value = null;

    // 自动填充
    if (field.source) {
      value = getNestedValue(
        {document: userDocument, trip: tripInfo}, 
        field.source
      );
    }

    // 使用默认值
    if (!value && field.default) {
      value = field.default;
    }

    return {
      ...field,
      value: value,
      filled: !!value
    };
  });

  return {
    template: template,
    fields: filledForm,
    generated: new Date().toISOString(),
    offline: true
  };
}

function getNestedValue(obj, path) {
  return path.split('.').reduce((acc, part) => acc?.[part], obj);
}
```

### 3.4 离线问答卡

**预缓存策略：**
```javascript
// /lib/offlineQAGenerator.js
import policies from '@/data/offlinePolicies.json';

export async function generateQACardOffline(
  destination, 
  userInfo
) {
  const policy = policies.countries[destination];
  const questions = policy.commonQuestions;

  // 使用用户信息填充答案模板
  const filledQuestions = questions.map(q => {
    let answer = q.answerTemplate || q.answerZh;

    // 替换占位符
    if (q.answerTemplate) {
      answer = q.answerTemplate
        .replace('{duration}', userInfo.duration)
        .replace('{hotel}', userInfo.hotel?.name)
        .replace('{purpose}', userInfo.purpose || '旅游');
    }

    return {
      id: q.id,
      question: {
        local: q.questionCn || q.questionZh, // 当地语言
        chinese: q.questionZh,
        english: q.questionEn
      },
      answer: {
        local: q.answerCn || q.answerZh,
        chinese: answer,
        english: q.answerEn
      }
    };
  });

  return {
    destination,
    questions: filledQuestions,
    generated: new Date().toISOString(),
    offline: true
  };
}
```

---

## 四、网络状态智能管理

### 4.1 网络检测

```javascript
// /lib/networkManager.js
import NetInfo from '@react-native-community/netinfo';

class NetworkManager {
  constructor() {
    this.isConnected = false;
    this.connectionType = 'unknown';
    this.isExpensive = false;
    this.listeners = [];
  }

  // 初始化网络监听
  initialize() {
    NetInfo.addEventListener(state => {
      this.isConnected = state.isConnected;
      this.connectionType = state.type; // wifi, cellular, none
      this.isExpensive = state.details?.isConnectionExpensive;

      console.log('📶 网络状态:', {
        connected: this.isConnected,
        type: this.connectionType,
        expensive: this.isExpensive
      });

      // 通知所有监听器
      this.listeners.forEach(callback => callback(state));
    });
  }

  // 检查是否应该使用云端API
  shouldUseCloudAPI() {
    // WiFi: 优先使用云端API (更准确)
    if (this.connectionType === 'wifi' && this.isConnected) {
      return true;
    }

    // 移动网络但便宜: 可以使用
    if (this.connectionType === 'cellular' && 
        this.isConnected && 
        !this.isExpensive) {
      return true;
    }

    // 其他情况: 使用本地
    return false;
  }

  // 添加网络状态监听
  addListener(callback) {
    this.listeners.push(callback);
  }

  // 智能API调用（自动降级）
  async smartAPICall(
    cloudFn, 
    localFn, 
    options = {}
  ) {
    const { forceCloud = false, timeout = 10000 } = options;

    // 如果强制云端或网络条件好
    if (forceCloud || this.shouldUseCloudAPI()) {
      try {
        // 带超时的云端调用
        const result = await Promise.race([
          cloudFn(),
          new Promise((_, reject) => 
            setTimeout(() => reject(new Error('Timeout')), timeout)
          )
        ]);

        return {
          success: true,
          data: result,
          source: 'cloud'
        };
      } catch (error) {
        console.log('☁️ 云端API失败，降级到本地', error);
      }
    }

    // 降级到本地
    try {
      const result = await localFn();
      return {
        success: true,
        data: result,
        source: 'local'
      };
    } catch (error) {
      return {
        success: false,
        error: error.message,
        source: 'failed'
      };
    }
  }
}

export default new NetworkManager();
```

### 4.2 离线队列管理

```javascript
// /lib/offlineQueue.js
import AsyncStorage from '@react-native-async-storage/async-storage';
import NetworkManager from './networkManager';

class OfflineQueue {
  constructor() {
    this.queue = [];
    this.processing = false;
  }

  // 添加任务到队列
  async addTask(task) {
    const taskWithId = {
      id: Date.now().toString(),
      ...task,
      createdAt: new Date().toISOString(),
      retryCount: 0
    };

    this.queue.push(taskWithId);
    await this.saveQueue();

    console.log('📥 任务已加入离线队列:', taskWithId.id);

    // 如果有网络，立即尝试处理
    if (NetworkManager.isConnected) {
      this.processQueue();
    }
  }

  // 处理队列
  async processQueue() {
    if (this.processing || this.queue.length === 0) {
      return;
    }

    this.processing = true;
    console.log('⚙️ 开始处理离线队列，共', this.queue.length, '个任务');

    while (this.queue.length > 0) {
      const task = this.queue[0];

      try {
        await this.executeTask(task);
        
        // 成功，移除任务
        this.queue.shift();
        await this.saveQueue();
        
        console.log('✅ 任务完成:', task.id);
      } catch (error) {
        console.error('❌ 任务失败:', task.id, error);

        // 增加重试次数
        task.retryCount++;

        // 最多重试3次
        if (task.retryCount >= 3) {
          console.log('🚫 任务重试次数超限，移除:', task.id);
          this.queue.shift();
        } else {
          // 移到队列末尾，稍后重试
          this.queue.push(this.queue.shift());
        }

        await this.saveQueue();
        
        // 等待3秒再继续
        await new Promise(resolve => setTimeout(resolve, 3000));
      }
    }

    this.processing = false;
    console.log('🎉 离线队列处理完毕');
  }

  // 执行单个任务
  async executeTask(task) {
    switch (task.type) {
      case 'upload_file':
        return await this.uploadFile(task.data);
      
      case 'sync_document':
        return await this.syncDocument(task.data);
      
      case 'backup_trip':
        return await this.backupTrip(task.data);
      
      default:
        throw new Error(`未知任务类型: ${task.type}`);
    }
  }

  // 保存队列到本地
  async saveQueue() {
    await AsyncStorage.setItem(
      'offline_queue',
      JSON.stringify(this.queue)
    );
  }

  // 从本地加载队列
  async loadQueue() {
    const data = await AsyncStorage.getItem('offline_queue');
    if (data) {
      this.queue = JSON.parse(data);
      console.log('📂 已加载离线队列:', this.queue.length, '个任务');
    }
  }

  // 上传文件
  async uploadFile(fileData) {
    // 实现文件上传逻辑
    console.log('📤 上传文件:', fileData.fileName);
  }

  // 同步证件
  async syncDocument(documentData) {
    // 实现证件同步逻辑
    console.log('🔄 同步证件:', documentData.type);
  }

  // 备份行程
  async backupTrip(tripData) {
    // 实现行程备份逻辑
    console.log('💾 备份行程:', tripData.destination);
  }
}

export default new OfflineQueue();
```

### 4.3 用户UI提示

```javascript
// /components/NetworkStatusBar.jsx
import { View, Text } from 'react-native';
import { useNetworkStatus } from '@/hooks/useNetworkStatus';

export default function NetworkStatusBar() {
  const { isConnected, connectionType, isExpensive } = useNetworkStatus();

  if (isConnected && connectionType === 'wifi') {
    // WiFi连接，不显示提示
    return null;
  }

  if (!isConnected) {
    return (
      <View style={styles.offlineBanner}>
        <Text style={styles.offlineText}>
          📵 离线模式 - 所有功能仍可使用
        </Text>
      </View>
    );
  }

  if (isExpensive) {
    return (
      <View style={styles.expensiveBanner}>
        <Text style={styles.expensiveText}>
          💰 正在使用移动网络 - 已优化流量
        </Text>
      </View>
    );
  }

  return null;
}
```

---

## 五、首次启动数据预加载

### 5.1 预加载内容

```javascript
// /lib/dataPreloader.js
import AsyncStorage from '@react-native-async-storage/async-storage';
import * as FileSystem from 'expo-file-system';

class DataPreloader {
  async preloadOnFirstLaunch() {
    const hasPreloaded = await AsyncStorage.getItem('has_preloaded');
    
    if (hasPreloaded === 'true') {
      console.log('✅ 数据已预加载，跳过');
      return;
    }

    console.log('📥 首次启动，开始预加载数据...');

    await this.showPreloadUI(); // 显示加载UI

    try {
      // 1. 下载OCR模型（~50MB）
      await this.downloadOCRModels();
      
      // 2. 下载政策库（~5MB）
      await this.downloadPolicyDatabase();
      
      // 3. 下载表格模板（~2MB）
      await this.downloadFormTemplates();
      
      // 4. 下载翻译短语库（~3MB）
      await this.downloadTranslationCache();
      
      // 5. 初始化本地数据库
      await this.initializeLocalDatabase();

      await AsyncStorage.setItem('has_preloaded', 'true');
      await AsyncStorage.setItem('preload_date', new Date().toISOString());

      console.log('✅ 数据预加载完成');
      await this.hidePreloadUI();
    } catch (error) {
      console.error('❌ 预加载失败', error);
      await this.handlePreloadError(error);
    }
  }

  async downloadOCRModels() {
    console.log('📥 下载OCR模型...');
    
    const models = [
      {
        name: 'chinese_mobile_v2.0',
        url: 'https://paddleocr.bj.bcebos.com/PP-OCRv3/chinese/ch_PP-OCRv3_det_infer.tar',
        size: 25 * 1024 * 1024 // 25MB
      },
      {
        name: 'english_mobile_v2.0',
        url: 'https://paddleocr.bj.bcebos.com/PP-OCRv3/english/en_PP-OCRv3_det_infer.tar',
        size: 25 * 1024 * 1024 // 25MB
      }
    ];

    for (const model of models) {
      await this.downloadWithProgress(
        model.url,
        `${FileSystem.documentDirectory}ocr_models/${model.name}.tar`,
        model.size
      );
    }
  }

  async downloadPolicyDatabase() {
    console.log('📥 下载政策库...');
    
    const url = 'https://api.yourapp.com/data/policies.json';
    const localPath = `${FileSystem.documentDirectory}policies.json`;
    
    const response = await fetch(url);
    const data = await response.json();
    
    await FileSystem.writeAsStringAsync(
      localPath,
      JSON.stringify(data)
    );

    // 导入到SQLite
    await this.importPolicyToDatabase(data);
  }

  async downloadWithProgress(url, localPath, totalSize) {
    const downloadResumable = FileSystem.createDownloadResumable(
      url,
      localPath,
      {},
      (progress) => {
        const percent = (progress.totalBytesWritten / totalSize) * 100;
        console.log(`下载进度: ${percent.toFixed(1)}%`);
        this.updatePreloadProgress(percent);
      }
    );

    await downloadResumable.downloadAsync();
  }

  async showPreloadUI() {
    // 显示"正在准备离线数据"的全屏UI
    // 实现省略...
  }

  async updatePreloadProgress(percent) {
    // 更新进度条
    // 实现省略...
  }
}

export default new DataPreloader();
```

**预加载UI：**
```
┌────────────────────────────┐
│                            │
│     [App Logo]             │
│                            │
│  正在准备离线数据...       │
│                            │
│  [████████░░░░] 65%        │
│                            │
│  ✓ OCR模型                 │
│  ✓ 政策库                  │
│  → 表格模板...             │
│  ⏳ 翻译短语库...           │
│                            │
│  首次启动需要下载约60MB    │
│  之后可完全离线使用        │
│                            │
│  💡 建议在WiFi下完成       │
│                            │
└────────────────────────────┘
```

---

## 六、测试计划

### 6.1 离线模式测试

**测试场景：**

1. ✅ **完全离线测试**
   - 开启飞行模式
   - 扫描证件 → 应成功识别
   - 生成通关包 → 应成功生成
   - 查看问答卡 → 应正常显示

2. ✅ **弱网测试**
   - 限速到100kb/s
   - 观察是否自动降级到本地
   - API超时是否正确处理

3. ✅ **WiFi切换测试**
   - WiFi → 移动网络 → WiFi
   - 数据同步是否正常
   - 队列任务是否自动执行

4. ✅ **实地测试**
   - 深圳湾口岸（WiFi拥挤）
   - 香港机场（WiFi稳定）
   - 泰国机场（WiFi不稳定）

---

## 七、总结

### 7.1 核心优势

✅ **100%离线可用**
- 核心功能无需网络
- 适合边境WiFi不稳定环境

✅ **智能降级**
- 自动检测网络状况
- 优雅降级到本地

✅ **支持双护照**
- 中国大陆护照
- 香港特区护照

✅ **用户注册**
- 简单的邮箱/手机注册
- 云端数据加密备份

### 7.2 与竞品对比

| 功能 | 我们 | Google翻译 | iVisa | 其他旅行APP |
|------|-----|-----------|-------|------------|
| 离线OCR | ✅ | ❌ | ❌ | ❌ |
| 离线表格生成 | ✅ | ❌ | ❌ | ❌ |
| 边境场景优化 | ✅ | ❌ | ❌ | ❌ |
| 弱网自动降级 | ✅ | ⚠️ | ❌ | ❌ |
| 双护照支持 | ✅ | ❌ | ❌ | ❌ |

### 7.3 实施优先级

**第一阶段（Week 1-2）：**
- ✅ 本地OCR（PaddleOCR）
- ✅ 用户注册/登录
- ✅ 网络状态检测

**第二阶段（Week 3-4）：**
- ✅ 离线政策库
- ✅ 离线表格生成
- ✅ 预加载系统

**第三阶段（Week 5-6）：**
- ✅ 离线队列
- ✅ 数据同步
- ✅ 实地测试

---

**文档版本：** v1.0  
**最后更新：** 2025-06-01  
**状态：** 准备开始开发

---

END OF DOCUMENT
