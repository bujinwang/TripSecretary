# ç¦»çº¿æ¨¡å¼ - æŠ€æœ¯è®¾è®¡æ–‡æ¡£

> **æ ¸å¿ƒç›®æ ‡**: ç¡®ä¿ç”¨æˆ·åœ¨è¾¹å¢ƒã€WiFiä¸ç¨³å®šç¯å¢ƒä¸‹ä»èƒ½æ­£å¸¸ä½¿ç”¨APP
> **æ³¨æ„**: æ‰€æœ‰ç”¨æˆ·éƒ½éœ€è¦æ³¨å†Œè´¦å·ä½¿ç”¨ï¼Œæ— è®¿å®¢æ¨¡å¼

---

## ä¸€ã€ä¸ºä»€ä¹ˆéœ€è¦ç¦»çº¿æ¨¡å¼ï¼Ÿ

### 1.1 çœŸå®åœºæ™¯åˆ†æ

**åœºæ™¯1: æœºåœº/è¾¹å¢ƒå£å²¸ç½‘ç»œå·®**
```
ç”¨æˆ·åœ¨æ·±åœ³æ¹¾å£å²¸å‡†å¤‡è¿‡å…³å»é¦™æ¸¯
â”œâ”€â”€ æ‰‹æœºä¿¡å·ï¼šæ»¡æ ¼
â”œâ”€â”€ å®é™…ç½‘é€Ÿï¼š<100kb/s (å¤§é‡äººåŒæ—¶ç”¨WiFi)
â”œâ”€â”€ APIè°ƒç”¨ï¼šè¶…æ—¶
â””â”€â”€ é—®é¢˜ï¼šæ— æ³•ç”Ÿæˆé€šå…³åŒ… âŒ
```

**åœºæ™¯2: å›½é™…æ¼«æ¸¸è´¹è´µ**
```
ç”¨æˆ·åˆšä¸‹é£æœºåˆ°è¾¾æ³°å›½æ›¼è°·æœºåœº
â”œâ”€â”€ è¿˜æ²¡ä¹°å½“åœ°SIMå¡
â”œâ”€â”€ æ¼«æ¸¸è´¹ï¼šÂ¥3/MB
â”œâ”€â”€ åªèƒ½ç”¨æœºåœºå…è´¹WiFi
â””â”€â”€ WiFié€Ÿåº¦ï¼šä¸ç¨³å®šï¼Œæ—¶æ–­æ—¶ç»­
```

**åœºæ™¯3: å¿˜è®°æå‰ä¸‹è½½æ•°æ®**
```
ç‹é˜¿å§¨åœ¨é¦™æ¸¯æœºåœº
â”œâ”€â”€ æ‰‹æœºæ²¡ä¿¡å·
â”œâ”€â”€ WiFiè¿ä¸ä¸Š
â”œâ”€â”€ æµ·å…³å¿«åˆ°äº†ï¼Œå¾ˆç€æ€¥
â”œâ”€â”€ ä½†å¥¹å‡ºå‘å‰å·²ç»ç”Ÿæˆäº†é€šå…³åŒ…
â””â”€â”€ ç»“æœï¼šæ‰€æœ‰æ•°æ®å·²ç¼“å­˜ï¼Œå®Œå…¨ç¦»çº¿ä¹Ÿèƒ½ç”¨ â­
```

### 1.2 ç¦»çº¿èƒ½åŠ›åˆ†çº§

| åŠŸèƒ½ | åœ¨çº¿å¿…éœ€ï¼Ÿ | ç¦»çº¿å¯ç”¨ï¼Ÿ | ä¼˜å…ˆçº§ |
|------|----------|----------|-------|
| ğŸ“¸ æ‹ç…§è¯†åˆ«è¯ä»¶ | âŒ | âœ… æœ¬åœ°OCR | P0 |
| âœ“ éªŒè¯è¯ä»¶æœ‰æ•ˆæ€§ | âŒ | âœ… æœ¬åœ°è§„åˆ™åº“ | P0 |
| ğŸ“‹ ç”Ÿæˆå…¥å¢ƒè¡¨æ ¼ | âŒ | âœ… æœ¬åœ°æ¨¡æ¿ | P0 |
| ğŸ’¬ æµ·å…³é—®ç­”å¡ | âŒ | âœ… é¢„ç¼“å­˜ | P0 |
| ğŸ“± é€šå…³åŒ…å±•ç¤º | âŒ | âœ… å®Œå…¨ç¦»çº¿ | P0 |
| ğŸŒ å®æ—¶ç¿»è¯‘ | âš ï¸ | â–³ ç¼“å­˜å¸¸è§çŸ­è¯­ | P1 |
| â˜ï¸ äº‘ç«¯å¤‡ä»½ | âœ… | âŒ éœ€åœ¨çº¿ | P2 |
| ğŸ“¥ ä¸Šä¼ æ–‡ä»¶ | âœ… | âš ï¸ ç¦»çº¿é˜Ÿåˆ— | P2 |

**ç»“è®ºï¼šæ ¸å¿ƒåŠŸèƒ½100%ç¦»çº¿å¯ç”¨ â­**

---

## äºŒã€ç¦»çº¿æ¶æ„è®¾è®¡

### 2.1 ä¸‰å±‚æ•°æ®æ¶æ„

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚         Layer 1: æœ¬åœ°ä¼˜å…ˆå±‚             â”‚
â”‚  (Local First - 100%ç¦»çº¿å¯ç”¨)           â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  â€¢ PaddleOCR (è¯ä»¶è¯†åˆ«)                 â”‚
â”‚  â€¢ SQLite (è¯ä»¶æ•°æ®ã€æ”¿ç­–åº“)            â”‚
â”‚  â€¢ é¢„ç”Ÿæˆæ¨¡æ¿ (5å›½å…¥å¢ƒè¡¨æ ¼)             â”‚
â”‚  â€¢ é¢„ç¼“å­˜é—®ç­” (100+å¸¸è§é—®é¢˜)            â”‚
â”‚  â€¢ ç¿»è¯‘çŸ­è¯­åº“ (1000+å¸¸ç”¨çŸ­è¯­)           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
              â†“ æœ‰ç½‘ç»œæ—¶åŒæ­¥
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚         Layer 2: ç¼“å­˜å±‚                 â”‚
â”‚  (Cache - åŠ é€Ÿå“åº”)                     â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  â€¢ MMKV (å¿«é€ŸKVå­˜å‚¨)                    â”‚
â”‚  â€¢ Redis-likeç¼“å­˜ (APIå“åº”)             â”‚
â”‚  â€¢ å›¾ç‰‡ç¼“å­˜ (ç”¨æˆ·ä¸Šä¼ çš„æ–‡ä»¶)            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
              â†“ äº‘ç«¯å¤‡ä»½
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚         Layer 3: äº‘ç«¯åŒæ­¥å±‚             â”‚
â”‚  (Cloud Sync - å¯é€‰)                    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  â€¢ Cloudflare D1 (SQLiteåˆ†å¸ƒå¼)         â”‚
â”‚  â€¢ Cloudflare R2 (åŠ å¯†å¤‡ä»½)             â”‚
â”‚  â€¢ Workers API (åœ¨çº¿æ—¶åŒæ­¥)             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 2.2 æ ¸å¿ƒåŸåˆ™

1. **Local Firstï¼ˆæœ¬åœ°ä¼˜å…ˆï¼‰**
   - æ‰€æœ‰è¯»æ“ä½œä¼˜å…ˆä»æœ¬åœ°æ•°æ®åº“
   - å†™æ“ä½œç«‹å³å†™å…¥æœ¬åœ°ï¼Œåå°åŒæ­¥äº‘ç«¯

2. **Optimistic UIï¼ˆä¹è§‚æ›´æ–°ï¼‰**
   - ç”¨æˆ·æ“ä½œç«‹å³å“åº”ï¼Œä¸ç­‰ç½‘ç»œ
   - å¤±è´¥åå›æ»šæˆ–é‡è¯•

3. **Background Syncï¼ˆåå°åŒæ­¥ï¼‰**
   - æœ‰ç½‘ç»œæ—¶è‡ªåŠ¨åŒæ­¥
   - å¤±è´¥çš„æ“ä½œåŠ å…¥é˜Ÿåˆ—ï¼Œç¨åé‡è¯•

---

## ä¸‰ã€æ ¸å¿ƒåŠŸèƒ½ç¦»çº¿å®ç°

### 3.1 ç¦»çº¿OCRè¯†åˆ«

**æŠ€æœ¯æ–¹æ¡ˆï¼š**
```javascript
// /lib/offlineOCR.js
import PaddleOCR from 'react-native-paddle-ocr';
import Tesseract from 'tesseract.js';

class OfflineOCREngine {
  constructor() {
    this.paddleOCR = null;
    this.tesseract = null;
    this.initialized = false;
  }

  // åº”ç”¨å¯åŠ¨æ—¶åˆå§‹åŒ–ï¼ˆä¸‹è½½æ¨¡å‹ï¼‰
  async initialize() {
    try {
      // ä¸‹è½½PaddleOCRæ¨¡å‹ï¼ˆ~50MBï¼‰
      await PaddleOCR.downloadModels([
        'chinese_mobile_v2.0', // ä¸­æ–‡
        'english_mobile_v2.0'  // è‹±æ–‡
      ]);
      
      // åˆå§‹åŒ–Tesseractï¼ˆå¤‡ç”¨ï¼‰
      this.tesseract = await Tesseract.createWorker('chi_sim+eng');
      
      this.initialized = true;
      console.log('âœ… ç¦»çº¿OCRå¼•æ“åˆå§‹åŒ–æˆåŠŸ');
    } catch (error) {
      console.error('âš ï¸ ç¦»çº¿OCRåˆå§‹åŒ–å¤±è´¥', error);
    }
  }

  // ç¦»çº¿è¯†åˆ«æŠ¤ç…§
  async recognizePassport(imageUri) {
    if (!this.initialized) {
      throw new Error('OCRå¼•æ“æœªåˆå§‹åŒ–');
    }

    try {
      // ä¼˜å…ˆä½¿ç”¨PaddleOCRï¼ˆæ›´å¿«æ›´å‡†ï¼‰
      const result = await PaddleOCR.recognize({
        imagePath: imageUri,
        language: 'chinese+english',
        type: 'passport'
      });

      return {
        success: true,
        data: this.parsePassportData(result.text),
        confidence: result.confidence,
        source: 'paddle-ocr',
        offline: true
      };
    } catch (error) {
      // é™çº§åˆ°Tesseract
      console.log('PaddleOCRå¤±è´¥ï¼Œé™çº§åˆ°Tesseract');
      const result = await this.tesseract.recognize(imageUri);
      
      return {
        success: true,
        data: this.parsePassportData(result.data.text),
        confidence: result.data.confidence,
        source: 'tesseract',
        offline: true
      };
    }
  }

  // è§£ææŠ¤ç…§æ•°æ®
  parsePassportData(text) {
    // ä½¿ç”¨æ­£åˆ™æå–å…³é”®ä¿¡æ¯
    const patterns = {
      passportNumber: /[PEG]\d{8}/,
      name: /å§“å\/Name[:\s]+([A-Z\s]+)/,
      nationality: /å›½ç±\/Nationality[:\s]+([\u4e00-\u9fa5A-Z]+)/,
      dob: /å‡ºç”Ÿæ—¥æœŸ\/Date of birth[:\s]+(\d{4}[\.\/]\d{2}[\.\/]\d{2})/,
      expiry: /æœ‰æ•ˆæœŸè‡³\/Date of expiry[:\s]+(\d{4}[\.\/]\d{2}[\.\/]\d{2})/
    };

    const extracted = {};
    for (const [key, pattern] of Object.entries(patterns)) {
      const match = text.match(pattern);
      extracted[key] = match ? match[1] : null;
    }

    return extracted;
  }
}

export default new OfflineOCREngine();
```

**å…³é”®ç‚¹ï¼š**
- âœ… é¦–æ¬¡å®‰è£…æ—¶ä¸‹è½½OCRæ¨¡å‹åˆ°æœ¬åœ°
- âœ… å®Œå…¨ç¦»çº¿è¯†åˆ«ï¼Œæ— éœ€ç½‘ç»œ
- âœ… åŒå¼•æ“å¤‡ä»½ï¼ˆPaddleOCR + Tesseractï¼‰
- âš ï¸ æ¨¡å‹æ–‡ä»¶~50MBï¼Œéœ€æç¤ºç”¨æˆ·

### 3.2 ç¦»çº¿æ”¿ç­–åº“

**æ•°æ®ç»“æ„ï¼š**
```javascript
// /data/offlinePolicies.json
{
  "version": "2025-06-01",
  "countries": {
    "HK": {
      "name": "é¦™æ¸¯",
      "nameEn": "Hong Kong",
      "requirements": {
        "mainlandChina": {
          "document": "æ¸¯æ¾³é€šè¡Œè¯ + æœ‰æ•ˆç­¾æ³¨",
          "visaRequired": false,
          "arrivalCard": false,
          "passportValidity": "æœ‰æ•ˆæœŸå†…å³å¯",
          "stayDuration": "æ ¹æ®ç­¾æ³¨ç±»å‹ï¼ˆGç­¾7å¤©/14å¤©ï¼‰"
        },
        "hkResident": {
          "document": "é¦™æ¸¯èº«ä»½è¯ æˆ– é¦™æ¸¯æŠ¤ç…§",
          "visaRequired": false,
          "arrivalCard": false
        }
      },
      "commonQuestions": [
        {
          "id": "hk_q1",
          "questionCn": "åšŸåšä¹œï¼Ÿ",
          "questionZh": "æ¥åšä»€ä¹ˆï¼Ÿ",
          "questionEn": "Purpose of visit?",
          "answerCn": "æ—…éŠ",
          "answerZh": "æ—…æ¸¸",
          "answerEn": "Tourism"
        },
        {
          "id": "hk_q2",
          "questionCn": "é€—ç•™å¹¾è€ï¼Ÿ",
          "questionZh": "åœç•™å¤šä¹…ï¼Ÿ",
          "questionEn": "How long?",
          "answerTemplate": "{duration}æ—¥ / {duration}å¤© / {duration} days"
        }
        // ... æ›´å¤šé—®é¢˜
      ],
      "tips": [
        "æ— éœ€å¡«å†™å…¥å¢ƒå¡",
        "é€šå…³é€Ÿåº¦å¿«ï¼ˆ5-15åˆ†é’Ÿï¼‰",
        "å¯ä½¿ç”¨e-é“è‡ªåŠ©é€šå…³"
      ]
    },
    "TW": {
      "name": "å°æ¹¾",
      "requirements": {
        "mainlandChina": {
          "document": "å¤§é€šè¯ + å…¥å°è¯",
          "arrivalCard": true,
          "arrivalCardTemplate": "tw_arrival_card.json"
        }
      },
      // ... è¯¦ç»†æ”¿ç­–
    }
    // ... å…¶ä»–å›½å®¶
  }
}
```

**ç¦»çº¿éªŒè¯é€»è¾‘ï¼š**
```javascript
// /lib/offlineValidator.js
import policies from '@/data/offlinePolicies.json';

export async function validateOffline(document, destination) {
  const policy = policies.countries[destination];
  
  if (!policy) {
    return {
      valid: false,
      error: 'æš‚ä¸æ”¯æŒè¯¥ç›®çš„åœ°çš„ç¦»çº¿éªŒè¯'
    };
  }

  // æ ¹æ®è¯ä»¶ç±»å‹é€‰æ‹©è§„åˆ™
  const rules = document.type === 'hk_permit' 
    ? policy.requirements.mainlandChina
    : policy.requirements.default;

  // ç¦»çº¿éªŒè¯
  const checks = {
    documentValid: validateExpiry(document.expiryDate),
    passportValidity: checkPassportValidity(
      document.expiryDate, 
      rules.passportValidity
    ),
    visaRequired: rules.visaRequired
  };

  return {
    valid: Object.values(checks).every(c => c === true),
    checks,
    requirements: rules,
    tips: policy.tips
  };
}

function validateExpiry(expiryDate) {
  const expiry = new Date(expiryDate);
  const now = new Date();
  return expiry > now;
}

function checkPassportValidity(expiryDate, requirement) {
  if (requirement === 'æœ‰æ•ˆæœŸå†…å³å¯') return true;
  
  // è§£æ"â‰¥6ä¸ªæœˆ"ç­‰è¦æ±‚
  const months = parseInt(requirement.match(/\d+/)?.[0] || 0);
  const expiry = new Date(expiryDate);
  const minRequired = new Date();
  minRequired.setMonth(minRequired.getMonth() + months);
  
  return expiry >= minRequired;
}
```

### 3.3 ç¦»çº¿è¡¨æ ¼ç”Ÿæˆ

**é¢„ç”Ÿæˆæ¨¡æ¿ï¼š**
```javascript
// /data/templates/tw_arrival_card.json
{
  "id": "tw_arrival_card",
  "version": "2025",
  "name": "å°æ¹¾å…¥å¢ƒç™»è®°è¡¨",
  "nameTraditional": "è‡ºç£åœ°å€å…¥å¢ƒç™»è¨˜è¡¨",
  "fields": [
    {
      "id": "name",
      "labelTw": "å§“å",
      "labelCn": "å§“å",
      "labelEn": "Name",
      "type": "text",
      "source": "document.name", // ä»è¯ä»¶è‡ªåŠ¨å¡«å……
      "required": true
    },
    {
      "id": "permitNumber",
      "labelTw": "å¤§é™¸åœ°å€å±…æ°‘å¾€ä¾†è‡ºç£é€šè¡Œè­‰è™Ÿç¢¼",
      "labelCn": "å¤§é™†åœ°åŒºå±…æ°‘å¾€æ¥å°æ¹¾é€šè¡Œè¯å·ç ",
      "labelEn": "Mainland Travel Permit Number",
      "type": "text",
      "source": "document.number",
      "required": true
    },
    {
      "id": "purpose",
      "labelTw": "ä¾†è‡ºç›®çš„",
      "labelCn": "æ¥å°ç›®çš„",
      "labelEn": "Purpose of Visit",
      "type": "select",
      "options": [
        {"value": "tourism", "labelTw": "è§€å…‰", "labelCn": "è§‚å…‰", "labelEn": "Tourism"},
        {"value": "business", "labelTw": "å•†å‹™", "labelCn": "å•†åŠ¡", "labelEn": "Business"},
        {"value": "visiting", "labelTw": "æ¢è¦ª", "labelCn": "æ¢äº²", "labelEn": "Visiting Family"}
      ],
      "default": "tourism"
    },
    {
      "id": "duration",
      "labelTw": "åœç•™å¤©æ•¸",
      "labelCn": "åœç•™å¤©æ•°",
      "labelEn": "Duration (days)",
      "type": "number",
      "source": "trip.duration",
      "required": true
    },
    {
      "id": "addressInTW",
      "labelTw": "åœ¨è‡ºä½å€",
      "labelCn": "åœ¨å°ä½å€",
      "labelEn": "Address in Taiwan",
      "type": "text",
      "source": "trip.hotel.address",
      "required": true
    }
    // ... æ›´å¤šå­—æ®µ
  ]
}
```

**ç¦»çº¿ç”Ÿæˆå™¨ï¼š**
```javascript
// /lib/offlineFormGenerator.js
import templates from '@/data/templates';

export async function generateArrivalCardOffline(
  userDocument, 
  tripInfo, 
  destination
) {
  // åŠ è½½æ¨¡æ¿
  const template = templates[`${destination}_arrival_card`];
  
  if (!template) {
    throw new Error(`æ²¡æœ‰${destination}çš„ç¦»çº¿æ¨¡æ¿`);
  }

  // å¡«å……æ•°æ®
  const filledForm = template.fields.map(field => {
    let value = null;

    // è‡ªåŠ¨å¡«å……
    if (field.source) {
      value = getNestedValue(
        {document: userDocument, trip: tripInfo}, 
        field.source
      );
    }

    // ä½¿ç”¨é»˜è®¤å€¼
    if (!value && field.default) {
      value = field.default;
    }

    return {
      ...field,
      value: value,
      filled: !!value
    };
  });

  return {
    template: template,
    fields: filledForm,
    generated: new Date().toISOString(),
    offline: true
  };
}

function getNestedValue(obj, path) {
  return path.split('.').reduce((acc, part) => acc?.[part], obj);
}
```

### 3.4 ç¦»çº¿é—®ç­”å¡

**é¢„ç¼“å­˜ç­–ç•¥ï¼š**
```javascript
// /lib/offlineQAGenerator.js
import policies from '@/data/offlinePolicies.json';

export async function generateQACardOffline(
  destination, 
  userInfo
) {
  const policy = policies.countries[destination];
  const questions = policy.commonQuestions;

  // ä½¿ç”¨ç”¨æˆ·ä¿¡æ¯å¡«å……ç­”æ¡ˆæ¨¡æ¿
  const filledQuestions = questions.map(q => {
    let answer = q.answerTemplate || q.answerZh;

    // æ›¿æ¢å ä½ç¬¦
    if (q.answerTemplate) {
      answer = q.answerTemplate
        .replace('{duration}', userInfo.duration)
        .replace('{hotel}', userInfo.hotel?.name)
        .replace('{purpose}', userInfo.purpose || 'æ—…æ¸¸');
    }

    return {
      id: q.id,
      question: {
        local: q.questionCn || q.questionZh, // å½“åœ°è¯­è¨€
        chinese: q.questionZh,
        english: q.questionEn
      },
      answer: {
        local: q.answerCn || q.answerZh,
        chinese: answer,
        english: q.answerEn
      }
    };
  });

  return {
    destination,
    questions: filledQuestions,
    generated: new Date().toISOString(),
    offline: true
  };
}
```

---

## å››ã€ç½‘ç»œçŠ¶æ€æ™ºèƒ½ç®¡ç†

### 4.1 ç½‘ç»œæ£€æµ‹

```javascript
// /lib/networkManager.js
import NetInfo from '@react-native-community/netinfo';

class NetworkManager {
  constructor() {
    this.isConnected = false;
    this.connectionType = 'unknown';
    this.isExpensive = false;
    this.listeners = [];
  }

  // åˆå§‹åŒ–ç½‘ç»œç›‘å¬
  initialize() {
    NetInfo.addEventListener(state => {
      this.isConnected = state.isConnected;
      this.connectionType = state.type; // wifi, cellular, none
      this.isExpensive = state.details?.isConnectionExpensive;

      console.log('ğŸ“¶ ç½‘ç»œçŠ¶æ€:', {
        connected: this.isConnected,
        type: this.connectionType,
        expensive: this.isExpensive
      });

      // é€šçŸ¥æ‰€æœ‰ç›‘å¬å™¨
      this.listeners.forEach(callback => callback(state));
    });
  }

  // æ£€æŸ¥æ˜¯å¦åº”è¯¥ä½¿ç”¨äº‘ç«¯API
  shouldUseCloudAPI() {
    // WiFi: ä¼˜å…ˆä½¿ç”¨äº‘ç«¯API (æ›´å‡†ç¡®)
    if (this.connectionType === 'wifi' && this.isConnected) {
      return true;
    }

    // ç§»åŠ¨ç½‘ç»œä½†ä¾¿å®œ: å¯ä»¥ä½¿ç”¨
    if (this.connectionType === 'cellular' && 
        this.isConnected && 
        !this.isExpensive) {
      return true;
    }

    // å…¶ä»–æƒ…å†µ: ä½¿ç”¨æœ¬åœ°
    return false;
  }

  // æ·»åŠ ç½‘ç»œçŠ¶æ€ç›‘å¬
  addListener(callback) {
    this.listeners.push(callback);
  }

  // æ™ºèƒ½APIè°ƒç”¨ï¼ˆè‡ªåŠ¨é™çº§ï¼‰
  async smartAPICall(
    cloudFn, 
    localFn, 
    options = {}
  ) {
    const { forceCloud = false, timeout = 10000 } = options;

    // å¦‚æœå¼ºåˆ¶äº‘ç«¯æˆ–ç½‘ç»œæ¡ä»¶å¥½
    if (forceCloud || this.shouldUseCloudAPI()) {
      try {
        // å¸¦è¶…æ—¶çš„äº‘ç«¯è°ƒç”¨
        const result = await Promise.race([
          cloudFn(),
          new Promise((_, reject) => 
            setTimeout(() => reject(new Error('Timeout')), timeout)
          )
        ]);

        return {
          success: true,
          data: result,
          source: 'cloud'
        };
      } catch (error) {
        console.log('â˜ï¸ äº‘ç«¯APIå¤±è´¥ï¼Œé™çº§åˆ°æœ¬åœ°', error);
      }
    }

    // é™çº§åˆ°æœ¬åœ°
    try {
      const result = await localFn();
      return {
        success: true,
        data: result,
        source: 'local'
      };
    } catch (error) {
      return {
        success: false,
        error: error.message,
        source: 'failed'
      };
    }
  }
}

export default new NetworkManager();
```

### 4.2 ç¦»çº¿é˜Ÿåˆ—ç®¡ç†

```javascript
// /lib/offlineQueue.js
import AsyncStorage from '@react-native-async-storage/async-storage';
import NetworkManager from './networkManager';

class OfflineQueue {
  constructor() {
    this.queue = [];
    this.processing = false;
  }

  // æ·»åŠ ä»»åŠ¡åˆ°é˜Ÿåˆ—
  async addTask(task) {
    const taskWithId = {
      id: Date.now().toString(),
      ...task,
      createdAt: new Date().toISOString(),
      retryCount: 0
    };

    this.queue.push(taskWithId);
    await this.saveQueue();

    console.log('ğŸ“¥ ä»»åŠ¡å·²åŠ å…¥ç¦»çº¿é˜Ÿåˆ—:', taskWithId.id);

    // å¦‚æœæœ‰ç½‘ç»œï¼Œç«‹å³å°è¯•å¤„ç†
    if (NetworkManager.isConnected) {
      this.processQueue();
    }
  }

  // å¤„ç†é˜Ÿåˆ—
  async processQueue() {
    if (this.processing || this.queue.length === 0) {
      return;
    }

    this.processing = true;
    console.log('âš™ï¸ å¼€å§‹å¤„ç†ç¦»çº¿é˜Ÿåˆ—ï¼Œå…±', this.queue.length, 'ä¸ªä»»åŠ¡');

    while (this.queue.length > 0) {
      const task = this.queue[0];

      try {
        await this.executeTask(task);
        
        // æˆåŠŸï¼Œç§»é™¤ä»»åŠ¡
        this.queue.shift();
        await this.saveQueue();
        
        console.log('âœ… ä»»åŠ¡å®Œæˆ:', task.id);
      } catch (error) {
        console.error('âŒ ä»»åŠ¡å¤±è´¥:', task.id, error);

        // å¢åŠ é‡è¯•æ¬¡æ•°
        task.retryCount++;

        // æœ€å¤šé‡è¯•3æ¬¡
        if (task.retryCount >= 3) {
          console.log('ğŸš« ä»»åŠ¡é‡è¯•æ¬¡æ•°è¶…é™ï¼Œç§»é™¤:', task.id);
          this.queue.shift();
        } else {
          // ç§»åˆ°é˜Ÿåˆ—æœ«å°¾ï¼Œç¨åé‡è¯•
          this.queue.push(this.queue.shift());
        }

        await this.saveQueue();
        
        // ç­‰å¾…3ç§’å†ç»§ç»­
        await new Promise(resolve => setTimeout(resolve, 3000));
      }
    }

    this.processing = false;
    console.log('ğŸ‰ ç¦»çº¿é˜Ÿåˆ—å¤„ç†å®Œæ¯•');
  }

  // æ‰§è¡Œå•ä¸ªä»»åŠ¡
  async executeTask(task) {
    switch (task.type) {
      case 'upload_file':
        return await this.uploadFile(task.data);
      
      case 'sync_document':
        return await this.syncDocument(task.data);
      
      case 'backup_trip':
        return await this.backupTrip(task.data);
      
      default:
        throw new Error(`æœªçŸ¥ä»»åŠ¡ç±»å‹: ${task.type}`);
    }
  }

  // ä¿å­˜é˜Ÿåˆ—åˆ°æœ¬åœ°
  async saveQueue() {
    await AsyncStorage.setItem(
      'offline_queue',
      JSON.stringify(this.queue)
    );
  }

  // ä»æœ¬åœ°åŠ è½½é˜Ÿåˆ—
  async loadQueue() {
    const data = await AsyncStorage.getItem('offline_queue');
    if (data) {
      this.queue = JSON.parse(data);
      console.log('ğŸ“‚ å·²åŠ è½½ç¦»çº¿é˜Ÿåˆ—:', this.queue.length, 'ä¸ªä»»åŠ¡');
    }
  }

  // ä¸Šä¼ æ–‡ä»¶
  async uploadFile(fileData) {
    // å®ç°æ–‡ä»¶ä¸Šä¼ é€»è¾‘
    console.log('ğŸ“¤ ä¸Šä¼ æ–‡ä»¶:', fileData.fileName);
  }

  // åŒæ­¥è¯ä»¶
  async syncDocument(documentData) {
    // å®ç°è¯ä»¶åŒæ­¥é€»è¾‘
    console.log('ğŸ”„ åŒæ­¥è¯ä»¶:', documentData.type);
  }

  // å¤‡ä»½è¡Œç¨‹
  async backupTrip(tripData) {
    // å®ç°è¡Œç¨‹å¤‡ä»½é€»è¾‘
    console.log('ğŸ’¾ å¤‡ä»½è¡Œç¨‹:', tripData.destination);
  }
}

export default new OfflineQueue();
```

### 4.3 ç”¨æˆ·UIæç¤º

```javascript
// /components/NetworkStatusBar.jsx
import { View, Text } from 'react-native';
import { useNetworkStatus } from '@/hooks/useNetworkStatus';

export default function NetworkStatusBar() {
  const { isConnected, connectionType, isExpensive } = useNetworkStatus();

  if (isConnected && connectionType === 'wifi') {
    // WiFiè¿æ¥ï¼Œä¸æ˜¾ç¤ºæç¤º
    return null;
  }

  if (!isConnected) {
    return (
      <View style={styles.offlineBanner}>
        <Text style={styles.offlineText}>
          ğŸ“µ ç¦»çº¿æ¨¡å¼ - æ‰€æœ‰åŠŸèƒ½ä»å¯ä½¿ç”¨
        </Text>
      </View>
    );
  }

  if (isExpensive) {
    return (
      <View style={styles.expensiveBanner}>
        <Text style={styles.expensiveText}>
          ğŸ’° æ­£åœ¨ä½¿ç”¨ç§»åŠ¨ç½‘ç»œ - å·²ä¼˜åŒ–æµé‡
        </Text>
      </View>
    );
  }

  return null;
}
```

---

## äº”ã€é¦–æ¬¡å¯åŠ¨æ•°æ®é¢„åŠ è½½

### 5.1 é¢„åŠ è½½å†…å®¹

```javascript
// /lib/dataPreloader.js
import AsyncStorage from '@react-native-async-storage/async-storage';
import * as FileSystem from 'expo-file-system';

class DataPreloader {
  async preloadOnFirstLaunch() {
    const hasPreloaded = await AsyncStorage.getItem('has_preloaded');
    
    if (hasPreloaded === 'true') {
      console.log('âœ… æ•°æ®å·²é¢„åŠ è½½ï¼Œè·³è¿‡');
      return;
    }

    console.log('ğŸ“¥ é¦–æ¬¡å¯åŠ¨ï¼Œå¼€å§‹é¢„åŠ è½½æ•°æ®...');

    await this.showPreloadUI(); // æ˜¾ç¤ºåŠ è½½UI

    try {
      // 1. ä¸‹è½½OCRæ¨¡å‹ï¼ˆ~50MBï¼‰
      await this.downloadOCRModels();
      
      // 2. ä¸‹è½½æ”¿ç­–åº“ï¼ˆ~5MBï¼‰
      await this.downloadPolicyDatabase();
      
      // 3. ä¸‹è½½è¡¨æ ¼æ¨¡æ¿ï¼ˆ~2MBï¼‰
      await this.downloadFormTemplates();
      
      // 4. ä¸‹è½½ç¿»è¯‘çŸ­è¯­åº“ï¼ˆ~3MBï¼‰
      await this.downloadTranslationCache();
      
      // 5. åˆå§‹åŒ–æœ¬åœ°æ•°æ®åº“
      await this.initializeLocalDatabase();

      await AsyncStorage.setItem('has_preloaded', 'true');
      await AsyncStorage.setItem('preload_date', new Date().toISOString());

      console.log('âœ… æ•°æ®é¢„åŠ è½½å®Œæˆ');
      await this.hidePreloadUI();
    } catch (error) {
      console.error('âŒ é¢„åŠ è½½å¤±è´¥', error);
      await this.handlePreloadError(error);
    }
  }

  async downloadOCRModels() {
    console.log('ğŸ“¥ ä¸‹è½½OCRæ¨¡å‹...');
    
    const models = [
      {
        name: 'chinese_mobile_v2.0',
        url: 'https://paddleocr.bj.bcebos.com/PP-OCRv3/chinese/ch_PP-OCRv3_det_infer.tar',
        size: 25 * 1024 * 1024 // 25MB
      },
      {
        name: 'english_mobile_v2.0',
        url: 'https://paddleocr.bj.bcebos.com/PP-OCRv3/english/en_PP-OCRv3_det_infer.tar',
        size: 25 * 1024 * 1024 // 25MB
      }
    ];

    for (const model of models) {
      await this.downloadWithProgress(
        model.url,
        `${FileSystem.documentDirectory}ocr_models/${model.name}.tar`,
        model.size
      );
    }
  }

  async downloadPolicyDatabase() {
    console.log('ğŸ“¥ ä¸‹è½½æ”¿ç­–åº“...');
    
    const url = 'https://api.yourapp.com/data/policies.json';
    const localPath = `${FileSystem.documentDirectory}policies.json`;
    
    const response = await fetch(url);
    const data = await response.json();
    
    await FileSystem.writeAsStringAsync(
      localPath,
      JSON.stringify(data)
    );

    // å¯¼å…¥åˆ°SQLite
    await this.importPolicyToDatabase(data);
  }

  async downloadWithProgress(url, localPath, totalSize) {
    const downloadResumable = FileSystem.createDownloadResumable(
      url,
      localPath,
      {},
      (progress) => {
        const percent = (progress.totalBytesWritten / totalSize) * 100;
        console.log(`ä¸‹è½½è¿›åº¦: ${percent.toFixed(1)}%`);
        this.updatePreloadProgress(percent);
      }
    );

    await downloadResumable.downloadAsync();
  }

  async showPreloadUI() {
    // æ˜¾ç¤º"æ­£åœ¨å‡†å¤‡ç¦»çº¿æ•°æ®"çš„å…¨å±UI
    // å®ç°çœç•¥...
  }

  async updatePreloadProgress(percent) {
    // æ›´æ–°è¿›åº¦æ¡
    // å®ç°çœç•¥...
  }
}

export default new DataPreloader();
```

**é¢„åŠ è½½UIï¼š**
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                            â”‚
â”‚     [App Logo]             â”‚
â”‚                            â”‚
â”‚  æ­£åœ¨å‡†å¤‡ç¦»çº¿æ•°æ®...       â”‚
â”‚                            â”‚
â”‚  [â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–‘â–‘â–‘â–‘] 65%        â”‚
â”‚                            â”‚
â”‚  âœ“ OCRæ¨¡å‹                 â”‚
â”‚  âœ“ æ”¿ç­–åº“                  â”‚
â”‚  â†’ è¡¨æ ¼æ¨¡æ¿...             â”‚
â”‚  â³ ç¿»è¯‘çŸ­è¯­åº“...           â”‚
â”‚                            â”‚
â”‚  é¦–æ¬¡å¯åŠ¨éœ€è¦ä¸‹è½½çº¦60MB    â”‚
â”‚  ä¹‹åå¯å®Œå…¨ç¦»çº¿ä½¿ç”¨        â”‚
â”‚                            â”‚
â”‚  ğŸ’¡ å»ºè®®åœ¨WiFiä¸‹å®Œæˆ       â”‚
â”‚                            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## å…­ã€æµ‹è¯•è®¡åˆ’

### 6.1 ç¦»çº¿æ¨¡å¼æµ‹è¯•

**æµ‹è¯•åœºæ™¯ï¼š**

1. âœ… **å®Œå…¨ç¦»çº¿æµ‹è¯•**
   - å¼€å¯é£è¡Œæ¨¡å¼
   - æ‰«æè¯ä»¶ â†’ åº”æˆåŠŸè¯†åˆ«
   - ç”Ÿæˆé€šå…³åŒ… â†’ åº”æˆåŠŸç”Ÿæˆ
   - æŸ¥çœ‹é—®ç­”å¡ â†’ åº”æ­£å¸¸æ˜¾ç¤º

2. âœ… **å¼±ç½‘æµ‹è¯•**
   - é™é€Ÿåˆ°100kb/s
   - è§‚å¯Ÿæ˜¯å¦è‡ªåŠ¨é™çº§åˆ°æœ¬åœ°
   - APIè¶…æ—¶æ˜¯å¦æ­£ç¡®å¤„ç†

3. âœ… **WiFiåˆ‡æ¢æµ‹è¯•**
   - WiFi â†’ ç§»åŠ¨ç½‘ç»œ â†’ WiFi
   - æ•°æ®åŒæ­¥æ˜¯å¦æ­£å¸¸
   - é˜Ÿåˆ—ä»»åŠ¡æ˜¯å¦è‡ªåŠ¨æ‰§è¡Œ

4. âœ… **å®åœ°æµ‹è¯•**
   - æ·±åœ³æ¹¾å£å²¸ï¼ˆWiFiæ‹¥æŒ¤ï¼‰
   - é¦™æ¸¯æœºåœºï¼ˆWiFiç¨³å®šï¼‰
   - æ³°å›½æœºåœºï¼ˆWiFiä¸ç¨³å®šï¼‰

---

## ä¸ƒã€æ€»ç»“

### 7.1 æ ¸å¿ƒä¼˜åŠ¿

âœ… **100%ç¦»çº¿å¯ç”¨**
- æ ¸å¿ƒåŠŸèƒ½æ— éœ€ç½‘ç»œ
- é€‚åˆè¾¹å¢ƒWiFiä¸ç¨³å®šç¯å¢ƒ

âœ… **æ™ºèƒ½é™çº§**
- è‡ªåŠ¨æ£€æµ‹ç½‘ç»œçŠ¶å†µ
- ä¼˜é›…é™çº§åˆ°æœ¬åœ°

âœ… **æ”¯æŒåŒæŠ¤ç…§**
- ä¸­å›½å¤§é™†æŠ¤ç…§
- é¦™æ¸¯ç‰¹åŒºæŠ¤ç…§

âœ… **ç”¨æˆ·æ³¨å†Œ**
- ç®€å•çš„é‚®ç®±/æ‰‹æœºæ³¨å†Œ
- äº‘ç«¯æ•°æ®åŠ å¯†å¤‡ä»½

### 7.2 ä¸ç«å“å¯¹æ¯”

| åŠŸèƒ½ | æˆ‘ä»¬ | Googleç¿»è¯‘ | iVisa | å…¶ä»–æ—…è¡ŒAPP |
|------|-----|-----------|-------|------------|
| ç¦»çº¿OCR | âœ… | âŒ | âŒ | âŒ |
| ç¦»çº¿è¡¨æ ¼ç”Ÿæˆ | âœ… | âŒ | âŒ | âŒ |
| è¾¹å¢ƒåœºæ™¯ä¼˜åŒ– | âœ… | âŒ | âŒ | âŒ |
| å¼±ç½‘è‡ªåŠ¨é™çº§ | âœ… | âš ï¸ | âŒ | âŒ |
| åŒæŠ¤ç…§æ”¯æŒ | âœ… | âŒ | âŒ | âŒ |

### 7.3 å®æ–½ä¼˜å…ˆçº§

**ç¬¬ä¸€é˜¶æ®µï¼ˆWeek 1-2ï¼‰ï¼š**
- âœ… æœ¬åœ°OCRï¼ˆPaddleOCRï¼‰
- âœ… ç”¨æˆ·æ³¨å†Œ/ç™»å½•
- âœ… ç½‘ç»œçŠ¶æ€æ£€æµ‹

**ç¬¬äºŒé˜¶æ®µï¼ˆWeek 3-4ï¼‰ï¼š**
- âœ… ç¦»çº¿æ”¿ç­–åº“
- âœ… ç¦»çº¿è¡¨æ ¼ç”Ÿæˆ
- âœ… é¢„åŠ è½½ç³»ç»Ÿ

**ç¬¬ä¸‰é˜¶æ®µï¼ˆWeek 5-6ï¼‰ï¼š**
- âœ… ç¦»çº¿é˜Ÿåˆ—
- âœ… æ•°æ®åŒæ­¥
- âœ… å®åœ°æµ‹è¯•

---

**æ–‡æ¡£ç‰ˆæœ¬ï¼š** v1.0  
**æœ€åæ›´æ–°ï¼š** 2025-06-01  
**çŠ¶æ€ï¼š** å‡†å¤‡å¼€å§‹å¼€å‘

---

END OF DOCUMENT
