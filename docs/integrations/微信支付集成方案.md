# 微信支付集成方案

> **核心目标**: 在React Native APP中集成微信支付

---

## 一、微信支付概述

### 1.1 微信支付类型

```
微信支付有多种类型:

1. APP支付 ⭐⭐⭐⭐⭐（我们用这个）
   - 在APP内调起微信支付
   - 适合：移动应用
   - 用户体验最好

2. H5支付 ⭐⭐⭐
   - 在手机浏览器中支付
   - 适合：网页
   - 体验稍差

3. JSAPI支付 ⭐⭐⭐⭐
   - 在微信内打开的网页
   - 适合：公众号、小程序
   - 我们不需要

4. Native支付 ⭐⭐
   - 扫码支付
   - 适合：PC网站
   - 我们不需要
```

**我们选择：APP支付**

---

## 二、申请微信支付

### 2.1 前置条件

```
必须先有:
✅ 微信开放平台账号（已申请，用于微信登录）
✅ 企业认证（¥300/年）

新增需要:
✅ 微信支付商户号
✅ 对公银行账户
✅ 营业执照
```

### 2.2 申请步骤

**Step 1: 申请微信支付商户号**

```
1. 登录微信支付商户平台
   https://pay.weixin.qq.com

2. 提交资料
   - 营业执照
   - 法人身份证
   - 对公银行账户
   - 经营场景说明

3. 审核时间
   - 1-5个工作日

4. 审核通过后获得
   - 商户号（MCHID）
   - API密钥（API Key）
   - 商户证书
```

**Step 2: 在微信开放平台关联商户号**

```
1. 登录微信开放平台
   https://open.weixin.qq.com

2. 进入你的APP
   "管理中心" → "移动应用" → "你的APP"

3. 关联商户号
   "支付功能" → "申请开通" → 输入商户号

4. 等待审核（1-3天）
```

### 2.3 费率

```
微信支付费率:

标准费率:
- 0.6% per transaction
- 最低: ¥0.01
- 无封顶

示例:
- 用户支付 ¥10 → 商家收到 ¥9.94（扣除¥0.06）
- 用户支付 ¥100 → 商家收到 ¥99.40（扣除¥0.60）

结算周期:
- T+1（次日到账）
- 自动结算到对公账户
```

---

## 三、技术实现

### 3.1 整体流程

```
┌─────────────────────────────────────────┐
│   用户在APP选择付费功能                 │
│   例如：购买高级会员 ¥99/年            │
└──────────────┬──────────────────────────┘
               │
               ↓
┌─────────────────────────────────────────┐
│   APP发送请求到后端                     │
│   POST /api/pay/create                  │
│   { amount: 99, product: 'vip' }        │
└──────────────┬──────────────────────────┘
               │
               ↓
┌─────────────────────────────────────────┐
│   Cloudflare Worker调用微信API          │
│   创建预支付订单                        │
│   获取: prepay_id                       │
└──────────────┬──────────────────────────┘
               │
               ↓
┌─────────────────────────────────────────┐
│   返回支付参数给APP                     │
│   { prepay_id, sign, timestamp... }     │
└──────────────┬──────────────────────────┘
               │
               ↓
┌─────────────────────────────────────────┐
│   APP调起微信支付                       │
│   跳转到微信APP                         │
└──────────────┬──────────────────────────┘
               │
               ↓
┌─────────────────────────────────────────┐
│   用户在微信APP中完成支付               │
│   输入密码/指纹/人脸                    │
└──────────────┬──────────────────────────┘
               │
               ↓
┌─────────────────────────────────────────┐
│   微信回调通知后端                      │
│   POST /api/pay/notify                  │
│   { transaction_id, status... }         │
└──────────────┬──────────────────────────┘
               │
               ↓
┌─────────────────────────────────────────┐
│   后端验证签名                          │
│   更新订单状态                          │
│   开通会员权限                          │
└──────────────┬──────────────────────────┘
               │
               ↓
┌─────────────────────────────────────────┐
│   返回APP，显示支付成功                 │
│   用户可以使用高级功能                  │
└─────────────────────────────────────────┘
```

### 3.2 前端实现（React Native）

**安装依赖：**

```bash
npm install react-native-wechat-lib
```

**配置和代码：**

```javascript
// /services/wechatPay.js
import * as WeChat from 'react-native-wechat-lib';

class WechatPayService {
  constructor() {
    // 初始化微信SDK（登录时已经初始化）
  }

  // 发起支付
  async pay(productId, amount) {
    try {
      // 1. 创建订单（调用后端）
      const orderResponse = await fetch('https://your-worker.workers.dev/api/pay/create', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${userToken}`
        },
        body: JSON.stringify({
          product_id: productId,
          amount: amount,
          user_id: userId
        })
      });

      const orderData = await orderResponse.json();

      if (!orderData.success) {
        throw new Error(orderData.message);
      }

      // 2. 调起微信支付
      const payResult = await WeChat.pay({
        partnerId: orderData.partnerId,     // 商户号
        prepayId: orderData.prepayId,       // 预支付ID
        nonceStr: orderData.nonceStr,       // 随机字符串
        timeStamp: orderData.timeStamp,     // 时间戳
        package: orderData.package,         // 扩展字段
        sign: orderData.sign                // 签名
      });

      console.log('✅ 支付成功', payResult);

      // 3. 支付成功后的处理
      return {
        success: true,
        message: '支付成功',
        orderId: orderData.orderId
      };

    } catch (error) {
      console.error('❌ 支付失败', error);

      // 处理不同的错误
      if (error.code === '-2') {
        // 用户取消
        return {
          success: false,
          message: '支付已取消',
          code: 'USER_CANCEL'
        };
      } else if (error.code === '-1') {
        // 支付失败
        return {
          success: false,
          message: '支付失败，请重试',
          code: 'PAY_FAILED'
        };
      } else {
        // 其他错误
        return {
          success: false,
          message: error.message || '支付出错',
          code: 'UNKNOWN_ERROR'
        };
      }
    }
  }

  // 查询订单状态
  async queryOrder(orderId) {
    const response = await fetch(
      `https://your-worker.workers.dev/api/pay/query/${orderId}`,
      {
        headers: {
          'Authorization': `Bearer ${userToken}`
        }
      }
    );

    return await response.json();
  }
}

export default new WechatPayService();
```

**使用示例（支付页面）：**

```javascript
// /screens/VIPUpgradeScreen.jsx
import React, { useState } from 'react';
import { View, Text, Button, Alert, ActivityIndicator } from 'react-native';
import WechatPayService from '@/services/wechatPay';

export default function VIPUpgradeScreen() {
  const [loading, setLoading] = useState(false);

  const handlePurchase = async () => {
    setLoading(true);

    try {
      const result = await WechatPayService.pay('vip_yearly', 99);

      if (result.success) {
        Alert.alert(
          '支付成功',
          '您已成为高级会员！',
          [
            {
              text: '确定',
              onPress: () => {
                // 刷新用户状态
                refreshUserStatus();
                // 跳转到会员页
                navigation.navigate('VIPBenefits');
              }
            }
          ]
        );
      } else if (result.code === 'USER_CANCEL') {
        // 用户取消，不提示错误
        console.log('用户取消支付');
      } else {
        Alert.alert('支付失败', result.message);
      }
    } catch (error) {
      Alert.alert('错误', '支付出错，请重试');
    } finally {
      setLoading(false);
    }
  };

  return (
    <View style={styles.container}>
      <Text style={styles.title}>升级高级会员</Text>

      <View style={styles.priceCard}>
        <Text style={styles.price}>¥99</Text>
        <Text style={styles.period}>/ 年</Text>
      </View>

      <View style={styles.benefits}>
        <Text style={styles.benefitItem}>✅ 无限次数生成通关包</Text>
        <Text style={styles.benefitItem}>✅ 优先AI处理</Text>
        <Text style={styles.benefitItem}>✅ 高级问答模板</Text>
        <Text style={styles.benefitItem}>✅ 云端备份</Text>
        <Text style={styles.benefitItem}>✅ 多设备同步</Text>
      </View>

      <Button
        title={loading ? '处理中...' : '微信支付'}
        onPress={handlePurchase}
        disabled={loading}
        color="#07C160" // 微信绿
      />

      {loading && (
        <ActivityIndicator size="large" color="#07C160" style={styles.loader} />
      )}

      <Text style={styles.hint}>
        点击支付即表示同意《会员服务协议》
      </Text>
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    padding: 20,
    backgroundColor: '#fff',
  },
  title: {
    fontSize: 28,
    fontWeight: 'bold',
    textAlign: 'center',
    marginBottom: 30,
  },
  priceCard: {
    flexDirection: 'row',
    justifyContent: 'center',
    alignItems: 'baseline',
    backgroundColor: '#f5f5f5',
    padding: 30,
    borderRadius: 10,
    marginBottom: 30,
  },
  price: {
    fontSize: 48,
    fontWeight: 'bold',
    color: '#07C160',
  },
  period: {
    fontSize: 20,
    color: '#666',
    marginLeft: 5,
  },
  benefits: {
    marginBottom: 30,
  },
  benefitItem: {
    fontSize: 16,
    marginBottom: 10,
    paddingLeft: 10,
  },
  hint: {
    marginTop: 20,
    fontSize: 12,
    color: '#999',
    textAlign: 'center',
  },
  loader: {
    marginTop: 20,
  }
});
```

---

### 3.3 后端实现（Cloudflare Worker）

**安装依赖：**

```bash
npm install crypto-js
```

**创建支付订单：**

```javascript
// workers/api/pay/create.js
import crypto from 'crypto';

export default {
  async fetch(request, env) {
    try {
      // 1. 获取请求参数
      const { product_id, amount, user_id } = await request.json();

      // 2. 验证用户token
      const userId = verifyToken(request.headers.get('Authorization'));
      if (!userId) {
        return new Response(JSON.stringify({ error: 'Unauthorized' }), {
          status: 401
        });
      }

      // 3. 创建订单号
      const orderId = generateOrderId(); // 如: 'TS20250601123456789'

      // 4. 保存订单到数据库
      await env.DB.prepare(`
        INSERT INTO orders (
          order_id,
          user_id,
          product_id,
          amount,
          status,
          created_at
        ) VALUES (?, ?, ?, ?, 'PENDING', datetime('now'))
      `).bind(orderId, userId, product_id, amount).run();

      // 5. 调用微信统一下单API
      const prepayData = await createWechatOrder({
        orderId: orderId,
        amount: amount,
        userId: userId,
        productName: getProductName(product_id),
        env: env
      });

      // 6. 返回支付参数给APP
      return new Response(JSON.stringify({
        success: true,
        orderId: orderId,
        ...prepayData
      }), {
        headers: { 'Content-Type': 'application/json' }
      });

    } catch (error) {
      console.error('创建订单失败:', error);
      return new Response(JSON.stringify({
        success: false,
        message: error.message
      }), {
        status: 500
      });
    }
  }
};

// 调用微信统一下单API
async function createWechatOrder({ orderId, amount, userId, productName, env }) {
  const appid = env.WECHAT_APP_ID;
  const mchid = env.WECHAT_MCHID; // 商户号
  const apiKey = env.WECHAT_API_KEY; // API密钥

  // 准备参数
  const nonceStr = generateNonceStr();
  const timestamp = Math.floor(Date.now() / 1000).toString();

  const params = {
    appid: appid,
    mch_id: mchid,
    nonce_str: nonceStr,
    body: productName, // 商品描述
    out_trade_no: orderId, // 商户订单号
    total_fee: amount * 100, // 金额（分）
    spbill_create_ip: '127.0.0.1',
    notify_url: 'https://your-worker.workers.dev/api/pay/notify',
    trade_type: 'APP'
  };

  // 生成签名
  const sign = generateSign(params, apiKey);
  params.sign = sign;

  // 转换为XML
  const xmlData = objectToXml(params);

  // 调用微信API
  const response = await fetch('https://api.mch.weixin.qq.com/pay/unifiedorder', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/xml'
    },
    body: xmlData
  });

  const xmlResponse = await response.text();
  const result = xmlToObject(xmlResponse);

  if (result.return_code !== 'SUCCESS' || result.result_code !== 'SUCCESS') {
    throw new Error(result.err_code_des || '微信下单失败');
  }

  // 获取prepay_id
  const prepayId = result.prepay_id;

  // 生成APP调起支付的参数
  const payParams = {
    appid: appid,
    partnerid: mchid,
    prepayid: prepayId,
    package: 'Sign=WXPay',
    noncestr: generateNonceStr(),
    timestamp: timestamp
  };

  // 生成签名
  payParams.sign = generateSign(payParams, apiKey);

  return {
    partnerId: mchid,
    prepayId: prepayId,
    nonceStr: payParams.noncestr,
    timeStamp: timestamp,
    package: payParams.package,
    sign: payParams.sign
  };
}

// 生成签名
function generateSign(params, apiKey) {
  // 1. 参数名ASCII码从小到大排序
  const keys = Object.keys(params).sort();
  
  // 2. 拼接字符串
  const stringA = keys
    .filter(key => params[key] !== '' && key !== 'sign')
    .map(key => `${key}=${params[key]}`)
    .join('&');
  
  // 3. 拼接API密钥
  const stringSignTemp = `${stringA}&key=${apiKey}`;
  
  // 4. MD5加密并转大写
  return crypto
    .createHash('md5')
    .update(stringSignTemp, 'utf8')
    .digest('hex')
    .toUpperCase();
}

// 生成随机字符串
function generateNonceStr() {
  return crypto.randomBytes(16).toString('hex');
}

// 生成订单号
function generateOrderId() {
  const date = new Date();
  const year = date.getFullYear();
  const month = String(date.getMonth() + 1).padStart(2, '0');
  const day = String(date.getDate()).padStart(2, '0');
  const hours = String(date.getHours()).padStart(2, '0');
  const minutes = String(date.getMinutes()).padStart(2, '0');
  const seconds = String(date.getSeconds()).padStart(2, '0');
  const random = Math.floor(Math.random() * 1000).toString().padStart(3, '0');
  
  return `TS${year}${month}${day}${hours}${minutes}${seconds}${random}`;
}

// 对象转XML
function objectToXml(obj) {
  let xml = '<xml>';
  for (const key in obj) {
    xml += `<${key}><![CDATA[${obj[key]}]]></${key}>`;
  }
  xml += '</xml>';
  return xml;
}

// XML转对象
function xmlToObject(xml) {
  const obj = {};
  const regex = /<(\w+)><!\[CDATA\[(.*?)\]\]><\/\1>/g;
  let match;
  
  while ((match = regex.exec(xml)) !== null) {
    obj[match[1]] = match[2];
  }
  
  return obj;
}

function getProductName(productId) {
  const products = {
    'vip_yearly': '高级会员-年费',
    'vip_monthly': '高级会员-月费',
    'credits_10': '10次生成额度',
    'credits_50': '50次生成额度'
  };
  return products[productId] || '通关助手服务';
}
```

**支付回调处理：**

```javascript
// workers/api/pay/notify.js
export default {
  async fetch(request, env) {
    try {
      // 1. 接收微信回调数据（XML格式）
      const xmlData = await request.text();
      console.log('收到微信回调:', xmlData);

      // 2. 解析XML
      const data = xmlToObject(xmlData);

      // 3. 验证签名
      const apiKey = env.WECHAT_API_KEY;
      const sign = data.sign;
      delete data.sign;
      
      const calculatedSign = generateSign(data, apiKey);
      
      if (sign !== calculatedSign) {
        console.error('❌ 签名验证失败');
        return new Response(failXml('签名验证失败'));
      }

      // 4. 检查支付结果
      if (data.return_code !== 'SUCCESS' || data.result_code !== 'SUCCESS') {
        console.error('❌ 支付失败:', data);
        return new Response(failXml('支付失败'));
      }

      // 5. 获取订单信息
      const orderId = data.out_trade_no;
      const transactionId = data.transaction_id;
      const totalFee = parseInt(data.total_fee) / 100; // 转为元

      // 6. 查询订单
      const order = await env.DB.prepare(
        'SELECT * FROM orders WHERE order_id = ?'
      ).bind(orderId).first();

      if (!order) {
        console.error('❌ 订单不存在:', orderId);
        return new Response(failXml('订单不存在'));
      }

      if (order.status === 'PAID') {
        console.log('⚠️ 订单已支付，跳过');
        return new Response(successXml());
      }

      // 7. 更新订单状态
      await env.DB.prepare(`
        UPDATE orders 
        SET 
          status = 'PAID',
          transaction_id = ?,
          paid_at = datetime('now')
        WHERE order_id = ?
      `).bind(transactionId, orderId).run();

      // 8. 处理业务逻辑（开通会员等）
      await handlePaymentSuccess(order, env);

      console.log('✅ 支付成功处理完成:', orderId);

      // 9. 返回成功给微信
      return new Response(successXml(), {
        headers: { 'Content-Type': 'application/xml' }
      });

    } catch (error) {
      console.error('处理回调失败:', error);
      return new Response(failXml('处理失败'), {
        headers: { 'Content-Type': 'application/xml' }
      });
    }
  }
};

// 处理支付成功后的业务逻辑
async function handlePaymentSuccess(order, env) {
  const userId = order.user_id;
  const productId = order.product_id;

  if (productId === 'vip_yearly') {
    // 开通年度会员
    const expiryDate = new Date();
    expiryDate.setFullYear(expiryDate.getFullYear() + 1);

    await env.DB.prepare(`
      UPDATE users 
      SET 
        is_vip = 1,
        vip_expiry = ?
      WHERE id = ?
    `).bind(expiryDate.toISOString(), userId).run();

  } else if (productId === 'vip_monthly') {
    // 开通月度会员
    const expiryDate = new Date();
    expiryDate.setMonth(expiryDate.getMonth() + 1);

    await env.DB.prepare(`
      UPDATE users 
      SET 
        is_vip = 1,
        vip_expiry = ?
      WHERE id = ?
    `).bind(expiryDate.toISOString(), userId).run();

  } else if (productId.startsWith('credits_')) {
    // 增加生成额度
    const credits = parseInt(productId.split('_')[1]);

    await env.DB.prepare(`
      UPDATE users 
      SET credits = credits + ?
      WHERE id = ?
    `).bind(credits, userId).run();
  }
}

// 成功返回给微信
function successXml() {
  return `
    <xml>
      <return_code><![CDATA[SUCCESS]]></return_code>
      <return_msg><![CDATA[OK]]></return_msg>
    </xml>
  `;
}

// 失败返回给微信
function failXml(message) {
  return `
    <xml>
      <return_code><![CDATA[FAIL]]></return_code>
      <return_msg><![CDATA[${message}]]></return_msg>
    </xml>
  `;
}
```

---

## 四、数据库设计

### 4.1 订单表

```sql
-- 创建订单表
CREATE TABLE orders (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  order_id TEXT UNIQUE NOT NULL,       -- 订单号
  user_id INTEGER NOT NULL,            -- 用户ID
  product_id TEXT NOT NULL,            -- 商品ID
  amount REAL NOT NULL,                -- 金额（元）
  status TEXT DEFAULT 'PENDING',       -- 状态：PENDING, PAID, FAILED, REFUNDED
  transaction_id TEXT,                 -- 微信交易号
  created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
  paid_at DATETIME,                    -- 支付时间
  
  FOREIGN KEY (user_id) REFERENCES users(id)
);

CREATE INDEX idx_orders_user ON orders(user_id);
CREATE INDEX idx_orders_status ON orders(status);

-- 商品表
CREATE TABLE products (
  id TEXT PRIMARY KEY,                 -- 商品ID
  name TEXT NOT NULL,                  -- 商品名称
  description TEXT,                    -- 描述
  price REAL NOT NULL,                 -- 价格（元）
  type TEXT NOT NULL,                  -- 类型：VIP, CREDITS
  duration INTEGER,                    -- 时长（天），VIP用
  credits INTEGER,                     -- 额度，CREDITS用
  active INTEGER DEFAULT 1             -- 是否启用
);

-- 插入商品
INSERT INTO products VALUES
  ('vip_yearly', '高级会员-年费', '无限次生成，优先处理', 99, 'VIP', 365, NULL, 1),
  ('vip_monthly', '高级会员-月费', '无限次生成，优先处理', 12, 'VIP', 30, NULL, 1),
  ('credits_10', '10次生成额度', '10次AI生成额度', 9.9, 'CREDITS', NULL, 10, 1),
  ('credits_50', '50次生成额度', '50次AI生成额度', 39.9, 'CREDITS', NULL, 50, 1);

-- 用户表增加VIP字段
ALTER TABLE users ADD COLUMN is_vip INTEGER DEFAULT 0;
ALTER TABLE users ADD COLUMN vip_expiry DATETIME;
ALTER TABLE users ADD COLUMN credits INTEGER DEFAULT 3; -- 免费用户3次
```

---

## 五、收费模式建议

### 5.1 推荐的定价策略

```
免费版（基础功能）:
✅ 每月3次生成额度
✅ 基础模板
✅ 本地存储
✅ 标准处理速度

高级会员（¥99/年 或 ¥12/月）:
✅ 无限次生成
✅ 所有模板
✅ 云端同步
✅ 优先AI处理（更快）
✅ 历史记录永久保存
✅ 多设备同步

单次购买（按需）:
✅ 10次额度 - ¥9.9
✅ 50次额度 - ¥39.9
```

### 5.2 定价心理学

```
为什么 ¥99/年 好于 ¥9/月？

¥9/月:
- 用户感觉: 每月付费，有压力
- 年总价: ¥108
- 续费率: 较低（60-70%）

¥99/年:
- 用户感觉: 一次性，划算
- 年总价: ¥99（便宜¥9）
- 续费率: 较高（75-85%）
- 提前锁定用户一年

推荐策略:
主推年费 ¥99
备选月费 ¥12（比¥9贵，引导用户买年费）
```

### 5.3 转化率优化

```javascript
// 在APP中展示价格对比
function PricingComparison() {
  return (
    <View>
      <View style={styles.planCard}>
        <Text style={styles.badge}>💰 最划算</Text>
        <Text style={styles.planName}>年度会员</Text>
        <Text style={styles.price}>¥99</Text>
        <Text style={styles.perMonth}>仅 ¥8.25/月</Text>
        <Text style={styles.savings}>比月付省 ¥45</Text>
        <Button title="立即购买" />
      </View>

      <View style={styles.planCard}>
        <Text style={styles.planName}>月度会员</Text>
        <Text style={styles.price}>¥12</Text>
        <Text style={styles.perMonth}>¥12/月</Text>
        <Button title="购买" variant="secondary" />
      </View>
    </View>
  );
}
```

---

## 六、测试

### 6.1 微信支付沙箱环境

```
微信提供沙箱环境测试:

1. 申请沙箱密钥
   https://pay.weixin.qq.com/wiki/doc/api/app/app.php?chapter=23_1

2. 使用沙箱账号测试
   - 不会真的扣款
   - 可以模拟各种支付场景

3. 测试用例
   ✅ 支付成功
   ✅ 支付失败
   ✅ 用户取消
   ✅ 网络超时
   ✅ 重复支付
   ✅ 退款
```

### 6.2 测试清单

```
□ 正常支付流程
□ 用户取消支付
□ 支付超时
□ 网络错误
□ 订单重复提交
□ 回调签名验证
□ 订单状态更新
□ 会员权限开通
□ 额度增加
□ APP支付参数正确性
```

---

## 七、安全注意事项

### 7.1 关键安全点

```
✅ API密钥保护
   - 存储在环境变量
   - 不要硬编码
   - 定期更换

✅ 签名验证
   - 所有请求验证签名
   - 防止篡改

✅ 回调验证
   - 验证微信IP白名单
   - 验证签名
   - 防止重放攻击

✅ 订单状态
   - 防止重复处理
   - 幂等性设计

✅ 金额验证
   - 前后端都验证
   - 防止篡改金额
```

### 7.2 安全代码示例

```javascript
// 验证回调IP（可选）
function verifyWechatIP(request) {
  const clientIP = request.headers.get('CF-Connecting-IP');
  const wechatIPs = [
    '101.226.103.*',
    '101.226.62.*',
    // ... 微信服务器IP段
  ];
  
  return wechatIPs.some(ip => {
    const pattern = ip.replace('*', '\\d+');
    return new RegExp(pattern).test(clientIP);
  });
}

// 防止重复回调
async function checkDuplicateCallback(orderId, env) {
  const lock = await env.MY_KV.get(`payment_lock:${orderId}`);
  
  if (lock) {
    throw new Error('订单正在处理中');
  }
  
  // 设置锁，5分钟过期
  await env.MY_KV.put(
    `payment_lock:${orderId}`, 
    '1', 
    { expirationTtl: 300 }
  );
}
```

---

## 八、退款处理

### 8.1 退款API

```javascript
// workers/api/pay/refund.js
export default {
  async fetch(request, env) {
    const { order_id, reason } = await request.json();

    // 1. 查询订单
    const order = await env.DB.prepare(
      'SELECT * FROM orders WHERE order_id = ? AND status = "PAID"'
    ).bind(order_id).first();

    if (!order) {
      return new Response(JSON.stringify({
        success: false,
        message: '订单不存在或未支付'
      }), { status: 404 });
    }

    // 2. 调用微信退款API
    const refundResult = await callWechatRefund({
      transactionId: order.transaction_id,
      totalFee: order.amount * 100,
      refundFee: order.amount * 100,
      orderId: order_id,
      reason: reason,
      env: env
    });

    if (refundResult.return_code !== 'SUCCESS') {
      throw new Error('退款失败');
    }

    // 3. 更新订单状态
    await env.DB.prepare(`
      UPDATE orders 
      SET status = 'REFUNDED', refund_at = datetime('now')
      WHERE order_id = ?
    `).bind(order_id).run();

    // 4. 撤销会员权限
    await revokeVIPAccess(order.user_id, env);

    return new Response(JSON.stringify({
      success: true,
      message: '退款成功'
    }));
  }
};
```

---

## 九、常见问题

### Q1: 微信支付费率可以协商吗？

**答：可以，但需要满足条件**
```
标准费率: 0.6%

可协商的情况:
- 交易量大（月流水 > 100万）
- 特殊行业（教育、公益等）
- 有议价能力的大客户

可能降至: 0.5% 或更低
```

### Q2: 支付失败怎么办？

**答：自动重试机制**
```javascript
async function payWithRetry(params, maxRetries = 3) {
  for (let i = 0; i < maxRetries; i++) {
    try {
      return await WeChat.pay(params);
    } catch (error) {
      if (i === maxRetries - 1) throw error;
      await sleep(1000 * (i + 1)); // 递增延迟
    }
  }
}
```

### Q3: 如何处理丢单（用户支付了但没到账）？

**答：主动查询**
```javascript
// 定时任务：查询pending超过10分钟的订单
async function checkPendingOrders(env) {
  const pendingOrders = await env.DB.prepare(`
    SELECT * FROM orders 
    WHERE status = 'PENDING' 
    AND created_at < datetime('now', '-10 minutes')
  `).all();

  for (const order of pendingOrders.results) {
    // 调用微信查询API
    const result = await queryWechatOrder(order.order_id, env);
    
    if (result.trade_state === 'SUCCESS') {
      // 补单
      await handlePaymentSuccess(order, env);
    }
  }
}
```

---

## 十、总结

### ✅ 完整流程

```
1. 申请微信支付商户号
   └─ 1-5个工作日

2. 前端集成
   └─ react-native-wechat-lib

3. 后端实现
   └─ 创建订单 + 回调处理

4. 测试
   └─ 沙箱环境测试

5. 上线
   └─ 正式环境
```

### 💰 成本

```
微信支付费用:
- 手续费: 0.6% per transaction
- 提现费: 免费（T+1自动到账）

年度成本估算（1000用户，50%付费）:
- 500用户 × ¥99 = ¥49,500
- 手续费: ¥49,500 × 0.6% = ¥297
- 净收入: ¥49,203
```

### 🎯 推荐定价

```
主推: 年度会员 ¥99
备选: 月度会员 ¥12
按需: 额度包 ¥9.9 / ¥39.9

免费版: 每月3次，引导升级
```

### 📋 开发时间

```
Week 1: 申请商户号（等待审核）
Week 2: 前端集成测试
Week 3: 后端开发测试
Week 4: 联调上线

总计: 约1个月
```

**准备好开始集成了吗？** 💳

---

**文档版本：** v1.0  
**最后更新：** 2025-06-01  
**结论：微信支付是中国市场的最佳收费方案**

---

END OF DOCUMENT
